### THIS FILE PROVIDES OUR QUERYING INTERFACE WITH THE MODELS. THIS IS STRICTLY
### READ-ONLY.

from __future__ import print_function
from src.appContext import cliQuery, dbMaintenance
from src.schema import ModuleLoadRecord, LogFile
from datetime import datetime, timedelta
from collections import OrderedDict
from sqlalchemy import func, asc, desc
from sqlalchemy.dialects import sqlite
import sqlalchemy.sql

def getLogs(startTime, endTime,
            count='numLoads',
            dataAggregation=['module'],
            timeAggregation='month',
            filters={},
            sortBy='module',
            sortOrder='desc'):
  """ 
  Get logs between 'startTime' and 'endTime', selected according key-value args.
  
  'startTime' and 'endTime' are DateTime objects.

  'count' must be in ['numLoads', 'numUsers', 'none']
  
  'sortBy' must be set to an option which is being aggregated.
  
  'dataAggregation' must be a subset of ['module', 'version', 'user'], where
  'version' is present only if 'module' is as well.
  
  'timeAggregation' must be in ['timespan', 'year', 'month', 'day'], 
  
  'sortBy' must be in ['count', 'module', 'version', 'user'], and must be a
  feature listed in either dataAggregation, or 'count' if the value of count
  is not 'none'
  
  'sortOrder' must be in ['asc', 'desc']
  
  'filters' should be a dictionary. Keys represent properties to filter over, and
  their associated values are lists of valid matches. list-values are OR'd together,
  while key-values are AND'd together.
  For example:
  getLog(Datetime(1,1,1), DateTime(1999, 1, 1), 
         dataAggregation=['module', version']
         filters={ 'module' : ['R', 'openmpi'] })
  would return triples (count, module, version) between 1/1/1 and 1/1/1999,
  where module was either 'R' or 'openmpi'.
  Another example:
  getLog(Datetime(1,1,1), DateTime(1999, 1, 1), 
         dataAggregation=['module', version']
         filters={ 'module' : ['R', 'openmpi'], 'user' : ['grundoon'] })
  gives the same as above, except counts only those records generated by user
  'grundoon'.
  An empty filter dictionary means no filter.
  'filters' keys must be in ['module',
                             'version',
                             'user',
                             'lessThan',
                             'greaterThan']
                                                                                          
  non-existent or non-sensicle options will be overriden
  """
  # First, we sanitize the input options
  count = cleanCount(count)
  dataAggregation = cleanDataAggregation(dataAggregation)
  timeAggregation = cleanTimeAggregation(timeAggregation)
  filters = cleanFilters(filters, count)
  sortBy = cleanSortBy(sortBy, dataAggregation, count)
  sortOrder = cleanSortOrder(sortOrder)
  
  # second, we construct the columns and filters
  if count == 'numLoads':
    countColumn = [func.count(getattr(ModuleLoadRecord, dataAggregation[-1])).label('count')]
  elif count == 'numUsers':
    countColumn = [func.count(ModuleLoadRecord.user.distinct()).label('count')]
  else:
    countColumn = []
  #countColumn = [func.count(getattr(ModuleLoadRecord, dataAggregation[-2])).label('count')]
  #countColumn = [func.count(ModuleLoadRecord.user.distinct()).label('count')]
  if 'timespan' not in timeAggregation:
    timeColumns = [func.extract(opt, ModuleLoadRecord.loadDate).label(opt) 
                   for opt in timeAggregation]
  else: 
    timeAggregation = []
    timeColumns = []
  dataColumns = [getattr(ModuleLoadRecord, opt) 
                 for opt in dataAggregation]
  sortOrder = asc if sortOrder == 'asc' else desc
  sortByColumn = map(asc, timeColumns) + [sortOrder(sortBy)]

  timeFilters = [ModuleLoadRecord.loadDate >= startTime, 
                 ModuleLoadRecord.loadDate < endTime]
  dataFilters = []
  countFilters = [sqlalchemy.sql.true()]
  # We go through each key in filters, ORing the filters for every individual key
  for key in filters:
    if key in ['greaterThan', 'lessThan']:
      if key == 'greaterThan':
        criterion = 'count > ' + str(int(filters[key]))
      else:
        criterion = 'count < ' + str(int(filters[key]))
      countFilters = [sqlalchemy.sql.text(criterion)]
    else:
      # This is a place-holder that we need to begin building up the query.
      # It won't wreck our query since it's going to be OR'd with extra criteria
      criterion = sqlalchemy.sql.false()
      for val in filters[key]:
        criterion = criterion | (getattr(ModuleLoadRecord, key) == val)
      # Deal with the edge case that a filter list was empty
      if criterion != sqlalchemy.sql.false():
        dataFilters.append(criterion)

  # Now, the actual querying
  with cliQuery() as session:
    results = session.query(*(timeColumns + dataColumns + countColumn)) \
            .filter(*(timeFilters + dataFilters)) \
            .group_by(*(timeColumns + dataColumns)) \
            .order_by(*sortByColumn) \
            .having(*countFilters) \
            .all()
  if count == 'none':
    return (timeAggregation + dataAggregation, results)
  elif count == 'numUsers':
    return (timeAggregation + dataAggregation + ['uniqueUsers'], results)
  else:
    return (timeAggregation + dataAggregation + ['numLoads'], results)

def cleanCount(count):
  if count in ['numLoads', 'numUsers', 'none']:
    return count
  else:
    return 'numLoads'

def cleanDataAggregation(dataAggregation):
  # dataAggregation
  dataAggregation = list(OrderedDict.fromkeys(dataAggregation))
  dataAggregation = [opt for opt in dataAggregation if opt in ['module', 'version', 'user']]
  if 'version' in dataAggregation and 'module' not in dataAggregation:
    dataAggregation = [opt for opt in dataAggregation if opt != 'version']
  if 'version' in dataAggregation and 'module' in dataAggregation:
    vIndex = dataAggregation.index('version')
    mIndex = dataAggregation.index('module')
    if vIndex != mIndex + 1:
      del(dataAggregation[vIndex])
      dataAggregation.insert(mIndex + 1, 'version')
  if not dataAggregation:
    dataAggregation = ['module']
  return dataAggregation

def cleanTimeAggregation(timeAggregation):
  if 'timespan' == timeAggregation:
    timeAggregation = ['timespan']
  elif 'day' == timeAggregation:
    timeAggregation = ['year', 'month', 'day']
  elif 'month' == timeAggregation:
    timeAggregation = ['year', 'month']
  elif 'year' == timeAggregation:
    timeAggregation = ['year']
  else:
    timeAggregation = ['year', 'month']
  return timeAggregation

def cleanFilters(filters, count):
  if 'lessThan' in filters and count == 'none':
    filters.pop('lessThan', None)
  if 'greaterThan' in filters and count == 'none':
    filters.pop('greaterThan', None)
  keysToDelete = []
  for key in filters:
    if not filters[key] or key not in ['module', 'version', 'user', 'lessThan', 'greaterThan']:
      keysToDelete.append(key)
  for key in keysToDelete:
    filters.pop(key, None)
  return filters

def cleanSortBy(sortBy, dataAggregation, count):
  if sortBy == 'count' and count == 'none':
    sortBy = dataAggregation[0]
  elif sortBy != 'count' and sortBy not in dataAggregation:
    print("Cannot set option 'sortBy' to property not found in 'dataAggregation'!")
    sortBy = 'count'
  return sortBy

def cleanSortOrder(sortOrder):
  if sortOrder not in ['asc', 'desc']:
    sortOrder = 'desc'
  return sortOrder

def moduleLogAlreadyAdded(filename):
  with dbMaintenance() as session:
    return session.query(sqlalchemy.sql.exists().where(LogFile.filename == filename)).scalar()

def toLoadDate(dateString, timestamp):
  dateFormat = "%b-%d-%Y %H:%M:%S"
  dateString = dateString + " " + timestamp
  return datetime.strptime(dateString, dateFormat)
